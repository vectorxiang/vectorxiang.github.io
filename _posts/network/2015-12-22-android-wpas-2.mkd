---
layout: post
title: "Android 之 wpa_supplicant 操作流程"
description:
category: network
tags: [network, linux]
mathjax: 
chart:
comments: false
---
#Scan
回顾一下 ：

```c
=>wpa_supplicant_add_iface
 ==>wpa_supplicant_init_iface
     wpa_s->ctrl_iface = wpa_supplicant_ctrl_iface_init(wpa_s);
     ===>wpas_ctrl_iface_open_sock
           eloop_register_read_sock(priv->sock, wpa_supplicant_ctrl_iface_receive, wpa_s, priv);
```

client 发送的命令全部都由 wpa_supplicant_ctrl_iface_receive 来处理   

```c
static void wpa_supplicant_ctrl_iface_receive(int sock, void *eloop_ctx,void *sock_ctx)
{
	struct wpa_supplicant *wpa_s = eloop_ctx;
	struct ctrl_iface_priv *priv = sock_ctx;
	char buf[4096]; int res; struct sockaddr_un from;
	socklen_t fromlen = sizeof(from);
	char *reply = NULL; size_t reply_len = 0; int new_attached = 0;
	res = recvfrom(sock, buf, sizeof(buf) - 1, 0,(struct sockaddr *) &from, &fromlen);
	......
	buf[res] = '\0';
	// 客户端第一次和WPAS连接时， 需要发送"ATTACH"命令
	if (os_strcmp(buf, "ATTACH") == 0) {
		......// 略过相关处理
	}
	......// "DETACH"和"LEVEL"命令处理
	else {
		// 大部分的命令处理都在wpa_supplicant_ctrl_iface_process函数中
		reply = wpa_supplicant_ctrl_iface_process(wpa_s, buf,&reply_len);
	} 
	if (reply) {// 回复客户端
		sendto(sock, reply, reply_len, 0, (struct sockaddr *) &from,fromlen);
		os_free(reply);
	} ......

	/*
	Client成功ATTACH后， 将通知EAPOL模块。 因为有些认证流程需要用户的参与（ 例如输入密码之类的） ，
	所以当客户端连接上后， EAPOL模块将判断是否需要和客户端交互。 读者可阅读
	eapol_sm_notify_ctrl_attached函数。
	*/
	if (new_attached)
		eapol_sm_notify_ctrl_attached(wpa_s->eapol);
}
```
绝大部分命令都由wpa_supplicant_ctrl_iface_process函数处理    

```c
char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
					 char *buf, size_t *resp_len)
{
	char *reply;
	const int reply_size = 4096;
	int reply_len;

	......

	reply = os_malloc(reply_size);
	if (reply == NULL) {
		*resp_len = 1;
		return NULL;
	}

	os_memcpy(reply, "OK\n", 3);
	reply_len = 3;

	if (os_strcmp(buf, "PING") == 0) {
		os_memcpy(reply, "PONG\n", 5);
		reply_len = 5;
	} else if (os_strcmp(buf, "IFNAME") == 0) {
		reply_len = os_strlen(wpa_s->ifname);
		os_memcpy(reply, wpa_s->ifname, reply_len);
	}
         ......
	} else if (os_strcmp(buf, "SCAN") == 0) {
		wpas_ctrl_scan(wpa_s, NULL, reply, reply_size, &reply_len);
         }
         ......

	if (reply_len < 0) {
		os_memcpy(reply, "FAIL\n", 5);
		reply_len = 5;
	}

	*resp_len = reply_len;
	return reply;         
```

这里 “SCAN” 由 wpas_ctrl_scan 来处理

```c
=> wpas_ctrl_scan
 ==> wpa_supplicant_req_scan
   ===> eloop_register_timeout(sec, usec, wpa_supplicant_scan, wpa_s, NULL);
    ====> wpa_supplicant_trigger_scan
```

```c
int wpa_supplicant_trigger_scan(struct wpa_supplicant *wpa_s,
				struct wpa_driver_scan_params *params)
{
	struct wpa_driver_scan_params *ctx;

	if (wpa_s->scan_work) {
		wpa_dbg(wpa_s, MSG_INFO, "Reject scan trigger since one is already pending");
		return -1;
	}

	ctx = wpa_scan_clone_params(params);
	if (ctx == NULL)
		return -1;

	if (radio_add_work(wpa_s, 0, "scan", 0, wpas_trigger_scan_cb, ctx) < 0)
	{
		wpa_scan_free_params(ctx);
		return -1;
	}

	return 0;
}
```

