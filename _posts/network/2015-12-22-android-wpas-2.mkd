---
layout: post
title: "Android 之 wpa_supplicant 操作流程"
description:
category: network
tags: [network, linux]
mathjax: 
chart:
comments: false
---
#Scan
回顾一下 ：

```c
=>wpa_supplicant_add_iface
 ==>wpa_supplicant_init_iface
     wpa_s->ctrl_iface = wpa_supplicant_ctrl_iface_init(wpa_s);
     ===>wpas_ctrl_iface_open_sock
           eloop_register_read_sock(priv->sock, wpa_supplicant_ctrl_iface_receive, wpa_s, priv);
```

client 发送的命令全部都由 wpa_supplicant_ctrl_iface_receive 来处理   

```c
static void wpa_supplicant_ctrl_iface_receive(int sock, void *eloop_ctx,void *sock_ctx)
{
	struct wpa_supplicant *wpa_s = eloop_ctx;
	struct ctrl_iface_priv *priv = sock_ctx;
	char buf[4096]; int res; struct sockaddr_un from;
	socklen_t fromlen = sizeof(from);
	char *reply = NULL; size_t reply_len = 0; int new_attached = 0;
	res = recvfrom(sock, buf, sizeof(buf) - 1, 0,(struct sockaddr *) &from, &fromlen);
	......
	buf[res] = '\0';
	// 客户端第一次和WPAS连接时， 需要发送"ATTACH"命令
	if (os_strcmp(buf, "ATTACH") == 0) {
		......// 略过相关处理
	}
	......// "DETACH"和"LEVEL"命令处理
	else {
		// 大部分的命令处理都在wpa_supplicant_ctrl_iface_process函数中
		reply = wpa_supplicant_ctrl_iface_process(wpa_s, buf,&reply_len);
	} 
	if (reply) {// 回复客户端
		sendto(sock, reply, reply_len, 0, (struct sockaddr *) &from,fromlen);
		os_free(reply);
	} ......

	/*
	Client成功ATTACH后， 将通知EAPOL模块。 因为有些认证流程需要用户的参与（ 例如输入密码之类的） ，
	所以当客户端连接上后， EAPOL模块将判断是否需要和客户端交互。 读者可阅读
	eapol_sm_notify_ctrl_attached函数。
	*/
	if (new_attached)
		eapol_sm_notify_ctrl_attached(wpa_s->eapol);
}
```
绝大部分命令都由wpa_supplicant_ctrl_iface_process函数处理    

```c
char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
					 char *buf, size_t *resp_len)
{
	char *reply;
	const int reply_size = 4096;
	int reply_len;

	......

	reply = os_malloc(reply_size);
	if (reply == NULL) {
		*resp_len = 1;
		return NULL;
	}

	os_memcpy(reply, "OK\n", 3);
	reply_len = 3;

	if (os_strcmp(buf, "PING") == 0) {
		os_memcpy(reply, "PONG\n", 5);
		reply_len = 5;
	} else if (os_strcmp(buf, "IFNAME") == 0) {
		reply_len = os_strlen(wpa_s->ifname);
		os_memcpy(reply, wpa_s->ifname, reply_len);
	}
         ......
	} else if (os_strcmp(buf, "SCAN") == 0) {
		wpas_ctrl_scan(wpa_s, NULL, reply, reply_size, &reply_len);
         }
         ......

	if (reply_len < 0) {
		os_memcpy(reply, "FAIL\n", 5);
		reply_len = 5;
	}

	*resp_len = reply_len;
	return reply;         
```

这里 “SCAN” 由 wpas_ctrl_scan 来处理

```c
=> wpas_ctrl_scan
 ==> wpa_supplicant_req_scan
   ===> eloop_register_timeout(sec, usec, wpa_supplicant_scan, wpa_s, NULL);
    ====> wpa_supplicant_trigger_scan
```

```c
int wpa_supplicant_trigger_scan(struct wpa_supplicant *wpa_s,
				struct wpa_driver_scan_params *params)
{
	struct wpa_driver_scan_params *ctx;

	if (wpa_s->scan_work) {
		wpa_dbg(wpa_s, MSG_INFO, "Reject scan trigger since one is already pending");
		return -1;
	}

	ctx = wpa_scan_clone_params(params);
	if (ctx == NULL)
		return -1;

	if (radio_add_work(wpa_s, 0, "scan", 0, wpas_trigger_scan_cb, ctx) < 0)
	{
		wpa_scan_free_params(ctx);
		return -1;
	}

	return 0;
}
```
wpas_trigger_scan_cb 会去调用 driver interface 中的 scan2 , 目前使用的是 CONFIG_DRIVER_NL80211 ：    

```c
static int driver_nl80211_scan2(void *priv,
				struct wpa_driver_scan_params *params)
{
	struct i802_bss *bss = priv;
	return wpa_driver_nl80211_scan(bss, params);
}

int wpa_driver_nl80211_scan(struct i802_bss *bss,
			    struct wpa_driver_scan_params *params)
{
	struct wpa_driver_nl80211_data *drv = bss->drv;
	int ret = -1, timeout;
	struct nl_msg *msg = NULL;

	wpa_dbg(drv->ctx, MSG_DEBUG, "nl80211: scan request");
	drv->scan_for_auth = 0;

	msg = nl80211_scan_common(bss, NL80211_CMD_TRIGGER_SCAN, params);
	if (!msg)
		return -1;

	if (params->p2p_probe) {
		struct nlattr *rates;

		wpa_printf(MSG_DEBUG, "nl80211: P2P probe - mask SuppRates");

		rates = nla_nest_start(msg, NL80211_ATTR_SCAN_SUPP_RATES);
		if (rates == NULL)
			goto fail;

		/*
		 * Remove 2.4 GHz rates 1, 2, 5.5, 11 Mbps from supported rates
		 * by masking out everything else apart from the OFDM rates 6,
		 * 9, 12, 18, 24, 36, 48, 54 Mbps from non-MCS rates. All 5 GHz
		 * rates are left enabled.
		 */
		if (nla_put(msg, NL80211_BAND_2GHZ, 8,
			    "\x0c\x12\x18\x24\x30\x48\x60\x6c"))
			goto fail;
		nla_nest_end(msg, rates);

		if (nla_put_flag(msg, NL80211_ATTR_TX_NO_CCK_RATE))
			goto fail;
	}

         // 发送请求给wlan驱动。 返回值只是表示该命令是否正确发送给了驱动。 扫描结束事件将通过 driver event返回给WPAS。
	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
	msg = NULL;
	if (ret) {
		wpa_printf(MSG_DEBUG, "nl80211: Scan trigger failed: ret=%d "
			   "(%s)", ret, strerror(-ret));
		......
	}

	drv->scan_state = SCAN_REQUESTED;
	timeout = 10;
	if (drv->scan_complete_events) {
		/*
		 * The driver seems to deliver events to notify when scan is
		 * complete, so use longer timeout to avoid race conditions
		 * with scanning and following association request.
		 */
		timeout = 30;
	}
	eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv, drv->ctx);
         // timeout 为 10s
	eloop_register_timeout(timeout, 0, wpa_driver_nl80211_scan_timeout,
			       drv, drv->ctx);

fail:
	......
}
```
