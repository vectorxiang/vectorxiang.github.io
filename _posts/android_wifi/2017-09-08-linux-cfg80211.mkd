---
layout: post
title: "cfg80211"
category: android wifi
tags: [network, android , wifi, linux]
catalog: true
---
## 1. 简介
Linux 平台目前常用针对无线网络设备的API有两套 wext (Wireless Extensions) 和 nl80211 & cfg80211 ,  其主要区别是 wext 通过 ioctl 的方式来控制无线网卡驱动， 后者使用 netlink .

这里主要介绍 nl80211 和 cfg80211 , 其中 ， cfg80211用于驱动开发， 而 nl80211 API供用户空间进程使用以操作那些利用cfg80211 API开发的无线网卡驱动。 使用 nl80211 的 tool 包括 : iw , crda , hostapd , wpa_supplicant(with **-Dnl80211**)   

![](/images/network/wifi_architectrue.png) 

这里 wpas, iw 和 hostapd 通过 libnl 提供的接口向 cfg80211 发送消息， 其消息中的 cmd 的数据参数等由 nl80211 定义， 目前做的几个 Qcom/BCM wifi chip 的 android project 都属于 FullMAC (硬件管理MLME的无线网卡类型)  , 所以 cfg80211 会直接调用到 wlan driver 的接口， 其主要调用通过 cfg80211_ops 结构体。 

## 2. nl80211 
简单来说， nl80211的核心就是通过 netlink 机制向 Kernel 中的无线网卡驱动发送特定的消息。 只不过这些消息的类型、 参数等都由nl80211.h定义。   

### 2.1 scan 举例
以下通过 nl80211 触发driver 扫描为例 ：   

```c
@ wpa_supplicant/src/drivers/driver_nl80211_scan.c

int wpa_driver_nl80211_scan(struct i802_bss *bss,
			    struct wpa_driver_scan_params *params)
{
	struct nl_msg *msg = NULL;
	......
	// 创建nl80211消息， 其中NL80211_CMD_TRIGGER_SCAN是Nl80211定义的命令， 用于触发网络扫描
	msg = nl80211_scan_common(bss, NL80211_CMD_TRIGGER_SCAN, params);
	......
	// 发送netlink消息
	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
}

static struct nl_msg *
nl80211_scan_common(struct i802_bss *bss, u8 cmd,
		    struct wpa_driver_scan_params *params)
{
	struct nl_msg *msg;
	msg = nl80211_cmd_msg(bss, 0, cmd);
		struct nl_msg * nl80211_cmd_msg(struct i802_bss *bss, int flags, uint8_t cmd)
		{
			struct nl_msg *msg;
			// 分配 nl_msg
			msg = nlmsg_alloc();
			
			// 内部调用 genlmsg_put 填充 netlink 首部和 genl 首部中的 目的genl family id , fag 和 cmd
			if (!nl80211_cmd(bss->drv, msg, flags, cmd) ||
			    // 内部调用 nla_put_u32 填充nlattr type 为NL80211_ATTR_IFINDEX 和 data
			    nl80211_set_iface_id(msg, bss) < 0) {
				nlmsg_free(msg);
				return NULL;
			}

			return msg;
		}	
	...... // 其他消息处理
	return msg;
}
```
由上面的例子可知， nl80211其实就是利用netlink机制将一些802.11相关的命令和参数发送给驱动去执行。 这些命令和参数信息可通过nl80211头文件查询 :   

```c
@ wpa_supplicant/src/drivers/nl80211_copy.h

// 支持的所有 cmd
enum nl80211_commands {
	NL80211_CMD_UNSPEC		//unspecified command to catch errors
	NL80211_CMD_GET_WIPHY	//request information about a wiphy or dump request to get a list of all present wiphys.
	......
	NL80211_CMD_GET_SCAN	//get scan results
	NL80211_CMD_TRIGGER_SCAN	//trigger a new scan with the given parameters
	......
	__NL80211_CMD_AFTER_LAST,
	NL80211_CMD_MAX = __NL80211_CMD_AFTER_LAST - 1
}

// 支持的所有 attributes
enum nl80211_attrs {
/* don't change the order or add anything between, this is ABI! */
	NL80211_ATTR_UNSPEC,

	NL80211_ATTR_WIPHY,
	NL80211_ATTR_WIPHY_NAME,

	NL80211_ATTR_IFINDEX,
	NL80211_ATTR_IFNAME,
	NL80211_ATTR_IFTYPE,
	......
	__NL80211_ATTR_AFTER_LAST,
	NUM_NL80211_ATTR = __NL80211_ATTR_AFTER_LAST,
	NL80211_ATTR_MAX = __NL80211_ATTR_AFTER_LAST - 1
};	
```
上面给 family name 为 "nl80211" 的 gerneric netlink 发送了一个 cmd 为 NL80211_CMD_TRIGGER_SCAN 的消息 ,  我们来看 cfd80211 里面的代码 ：   

```c
@ kernel/net/wireless/nl80211.c

static const struct genl_ops nl80211_ops[] = {
	......
	{
		.cmd = NL80211_CMD_TRIGGER_SCAN,
		.doit = nl80211_trigger_scan,
		.policy = nl80211_policy,
		.flags = GENL_ADMIN_PERM,
		.internal_flags = NL80211_FLAG_NEED_WDEV_UP |
				  NL80211_FLAG_NEED_RTNL,
	},
	......
}

static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
{
	// 只看关键代码
	err = rdev_scan(rdev, request);
	......
}

static inline int rdev_scan(struct cfg80211_registered_device *rdev,
			    struct cfg80211_scan_request *request)
{
	int ret;
	ret = rdev->ops->scan(&rdev->wiphy, request);
	return ret;
}	
```
这里会在调用到已注册的 cfg80211 device 的 cfg80211_ops 的scan 函数 , 在看 wlan driver 中的定义   

```c
static struct cfg80211_ops wlan_hdd_cfg80211_ops =
{
	.......
	 .scan = wlan_hdd_cfg80211_scan,
}
```

### 2.2 libnl 简介
鉴于netlink的复杂性， 开源世界提供了几个较为完备的基于netlink编程的框架， 其中最著名的就是[libnl](http://www.infradead.org/~tgr/libnl/)  :    

![](/images/network/libnl.png ) 
· libnl-route： 用于和Kernel中的Routing子系统交互。   
· libnl-nf： 用于和Kernel中的Netfilter子系统交互。    
· libnl-genl： 用于和Kernel中的Generic Netlink模块交互。    

 在 Android 中移植了精简了libnl 和libnl-genl 的项目代码 external/libnl     
 libnl 重新封装了netlink原有的API ,  其使用时必须分配一个nl_sock结构体 . 以下介绍部分会用到的 libnl API  :   
 
```c
 /* 分配和释放 nl_sock */
struct nl_sock *nl_socket_alloc(void)
void nl_socket_free(struct nl_sock *sk)

// nl_connet内部将通过bind函数将netlink socket和protocol对应的模块进行绑定
int nl_connect(struct nl_sock *sk, int protocol)

// 为nl_sock对象设置一个回调函数， 当该socket上收到消息后， 就会回调此函数进行处理
void nl_socket_set_cb(struct nl_sock *sk, struct nl_cb *cb);
// 获取该nl_sock设置的回调函数信息
struct nl_cb *nl_socket_get_cb(const struct nl_sock *sk);

// 下面这两个函数计算netlink消息体中对应部分的长度
int nlmsg_size(int payloadlen); 	// 请参考图来理解这两个函数返回值的意义
int nlmsg_total_size(int payloadlen);
```
 ![](/images/network/genl_libnl_struct_len.PNG ) 
 
```c
/* nl_msg 的分配和释放 */
struct nl_msg *nlmsg_alloc(void);
void nlmsg_free(struct nl_msg *msg);

;
// nl_msg内部肯定会指向一个netlink消息头实例， 下面这个函数用于填充netlink消息头
struct nlmsghdr *nlmsg_put(struct nl_msg *msg,
	uint32_t port, uint32_t seqnr,
	int nlmsg_type, int payload, int nlmsg_flags);
	
// 直接发送netlink消息
int nl_sendto (struct nl_sock *sk, void *buf, size_t size)
// 发送nl_msg消息
int nl_send (struct nl_sock *sk, struct nl_msg *msg)
int nl_send_simple(struct nl_sock *sk, int type,
int flags,void *buf, size_t size);

。
// 核心接收函数。 nla参数用于存储发送端的地址信息。 creds用于存储权限相关的信息
int nl_recv(struct nl_sock *sk, struct sockaddr_nl *nla,
unsigned char **buf, struct ucred **creds)
// 内部通过nl_recv接收消息， 然后通过cb回调结构体中的回调函数传给接收者
int nl_recvmsgs (struct nl_sock *sk, struct nl_cb *cb)
```

** libnl-genl API 介绍**    
libnl-genl 基于libnl ， 封装了对generic netlink模块的处理 ：   

```c
// 根据family name字符串去查询family， 该函数内部实现将发送查询消息给Controller
int genl_ctrl_resolve (struct nl_sock *sk, const char *name)

// 和libnl的nl_connect类型， 只不过协议类型为GENERIC_NETLINK
int genl_connect (struct nl_sock *sk)

// genlmsg_put用于填充图中的nlmsghdr、 genlmsghder和用户自定义的消息头。 详细内容见下文
void* genlmsg_put (struct nl_msg *msg, uint32_t port,
	uint32_t seq, int family, int hdrlen,
	int flags, uint8_t cmd, uint8_t version)

// 用于获取genl消息中携带的nlattr内容
struct nlattr* genlmsg_attrdata(const struct genlmsghdr *gnlh,int hdrlen)
```
 



 

